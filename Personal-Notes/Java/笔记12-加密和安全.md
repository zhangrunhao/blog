# Java笔记 - 加密和安全

* 面对威胁做到
  * 防窃听
  * 防篡改
  * 防伪造
* 编写计算机程序做到:
  * 不要设计山寨的加密算法
  * 不要实现已有的加密算法
  * 不要修改已有的加密算法

## 编码算法

* ASCII编码, 127字符
* 中文使用`Unicode`编码
* 更加全面的是`UTF-8`

### URL编码

* 如果是ASCII编码能表示的, 就不改变
* 如果不是, 先转成`UTF-8`进行表示
* URL编码总是大写
* `URLEncoder`: 对任意字符进行编码
* `URLDecoder`: 进行解码
* URL编码是编码, 不是加密算法, 只是方便浏览器和服务器处理

### Base64编码

* **对二进制数据编码, 表示成文本格式**
* 可以把任意长度的二进制表示成纯文本
* 并且只包含: `A-Z, a-z, +, /, =`字符
* *3字节的二进制按照6bit一组, 用4个int整数表示, 整数用索引对照, 得到字符*
* 6位整数的范围`0-63`
* A-Z: 0-25
* a-z: 26-51
* 0-9: 52-61
* 62表示`+`;63表示`/`
* `=`表示一排的`0`
* 如果不是3的整倍数, 就在末尾添加, 一个或者两个`0x00`, 用1个或者2个`=`表示
* 编码的长度总是4的倍数, 所以不加`=`也可以计算出来: 使用`withoutPadding()`去掉`=`

* `+`, `/`, `=`不适合出现在URL中
* 针对URL的base64: `+`编程`-`, '/'变成`_`
* 有点: 在哪里都能存
* 确定: 原来的长度增加了1/3

## 哈希算法

* 又称: 摘要算法
* **对任意一组输入的数据进行计算, 得到一个固定长度的输出摘要**
* 特点:
  * 相同输入一定得到相同输出
  * 不同的输入大概率得到不同的输出
* 目的: 为了验证数据是否被篡改

* `hashCode()`: 哈希算法, 输入任意字符串, 输出是固定的4字节`int`的整数
* `HashMap()`基于`hashCode()`工作

### 哈希碰撞

* 不同的输入得到了相同的输出
* 碰撞是必然的, 只需要关注碰撞的概率
* 安全的哈希算法:
  * 碰撞率低
  * 不能猜测输出
* 常用的哈希算法:
  * MD5 128bits 16byte
  * SHA-1 160bits 20byte
  * RipeMD-160 160bits 20byte
  * SHA-256 25bits 32byte
  * SHA-512 512bits 64byte

```java
    // 创建一个MessageDigest实例
    MessageDigest md = MessageDigest.getInstance("MD5");
    // 反复调用update输入数据
    md.update("Hello".getBytes("UTF-8"));
    md.update("World".getBytes("UTF-8"));
    // `digest()`获取`byte[]`数组表示的摘要
    byte[] result = md.digest();
    // 转换为16进制的字字符串, 得到md5值
    System.out.println(new BigInteger(1, result).toString(16));
```

### 哈希算法用途

* 防止原始文件被篡改
* 存储用户口令
  * 用户口令使用hash算法之后, 进行存储
* 彩虹表攻击
  * 破解方法: 存储常用口令, 一次性破解
  * 抵御方法: 对每个口令添加随机数, 也就是`加盐`

### SHA-1

* 新的hash算法, 和`MD5`算法使用方法相同
* **MD5因为输入长度较短, 短时间破解是可能的, 不再推荐**

## BouncyCastle

* 提供很多哈希算法和加密算法的第三方库, 例如:`RipeMD16`哈希算法

## 疑问

### .classpath是什么

* `.classpath`文件中去除以下代码, 正常运行

```xml
    <attributes>
      <attribute name="module" value="true"/>
    </attributes>
```

* 否则报错

```shell
Error: Unable to initialize main class com.itranswarp.learnjava.Main
Caused by: java.lang.NoClassDefFoundError: org/bouncycastle/jce/provider/BouncyCastleProvider
```

## Hmac算法

* 加盐的目的是为了防止用户拿到原始口令
* Hmac: 基于密钥的消息认证码算法
* 和某种哈希算法配合使用
* HmacMD5: 带有一个安全的key的MD5, 不用加盐, 本质: 把key混进摘要的算法

```java
    KeyGenerator keyGen = KeyGenerator.getInstance("HmacMD5");
    SecretKey key = keyGen.generateKey();

    // 打印随机生成的key
    byte[] skey = key.getEncoded();
    System.out.println(new BigInteger(1, skey).toString(16));

    Mac mac = Mac.getInstance("HmacMD5");
    mac.init(key);
    mac.update("HelloWorld".getBytes("UTF-8"));
    byte[] result = mac.doFinal();
    System.out.println(new BigInteger(1, result).toString(16));
```

* 具体操作步骤:
  1. 通过`Hmac5`获取`KeyGenerator`
  2. 通过`KeyGenerator`创建一个`SecretKey`实例
  3. 通过名称`HmacMD5`获取`Mac`实例
  4. 用`SecretKey`初始化`Mac`实例
  5. `Mac`实例反复调用`update(byte[])`输入数据
  6. 调用`Mac`实例的`doFinal()`获取最终的哈希值

* 用`SecretKey`恢复`password`: 从`byte[]`数组中恢复
* 恢复`SecretKey`的语句就是: `new SecretKeySpec(hkey, "HmacMD5")`

```java
byte[] hkey = new byte[] {
    106, 70, -110, 125, 39, -20, 52, 56, 85, 9, -19, -72, 52, -53, 52, -45, -6, 119, -63,
    30, 20, -83, -28, 77, 98, 109, -32, -76, 121, -106, 0, -74, -107, -114, -45, 104, -104, -8, 2, 121, 6,
    97, -18, -13, -63, -30, -125, -103, -80, -46, 113, -14, 68, 32, -46, 101, -116, -104, -81, -108, 122,
    89, -106, -109
};
SecretKey key = new SecretKeySpec(hkey, "HmacMD5");
Mac mac = Mac.getInstance("HmacMD5");
mac.init(key);
mac.update("HelloWorld".getBytes("UTF-8"));
byte[] result = mac.doFinal();
System.out.println(Arrays.toString(result));
```
