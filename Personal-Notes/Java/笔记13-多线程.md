# Java笔记13 - 多线程

## 多线程基础

* 现代操作系统都可以同时执行多任务. 多任务就是同时运行多个任务
* CPU执行代码都是一条条执行. 操作系统可以让CPU对多个任务轮流执行

### 进程

* 一个任务是一个*进程*, 例如: 浏览器, 视频播放器
* 进程内部可以同时执行多个子任务: *线程*
* 一个进程可以包含一个或多个线程, 但至少会有一个线程
* 操作系统调用的最小任务单位是线程
* 同一个应用程序可以有多个进程, 也可以有多个线程
* 各种模式:
  * 多进程模式: 每个进程只有一个线程
  * 多线程模式: 一个进程有多个线程
  * 多进程 + 多线程模式

### 进程VS线程

* 多任务可以由多线程实现, 也可以单进程内的多线程, 也可以混合模式
* 多线程相比, 多进程缺点:
  * 进程比线程开销大,
  * 进程间的通信比线程慢, 因为线程间的通信就是读写同一个变量
* 多进程优点:
  * 多进程的稳定性高, 一个进程的崩溃不会影响其他进程
  * 多线程中, 有一个线程崩溃导致整个进程崩溃

### 多线程

* Java语言内置多线程支持
  * 一个Java程序就是一个JVM进程
  * JVM进程用一个主线程启用`main()`方法
  * `main()`方法内部, 可以启用多个线程
  * JVM内部负责垃圾回收其他线程

* Java多线程编程特点:
  * 多线程模型是JAVA程序最基本的并发模型
  * 后续读写网络, 数据库, Web开发等都需要依赖Java多线程模型

## 创建新线程

* 一个线程启动后, 如果什么也不做, 就结束了
* 方法一: `Thread`派生一个自定义类, 复写`run`方法
* 方法二: 创建`Thread`实例时, 传入一个`Runnable`实例
* 多个线程同时运行, 由操作系统调度, 程序本身无法确定线程的调度顺序
* 直接调用`Thread.run()`是无效的, 相当于直接执行java代码主线程
* 可以使用`Thread.setPriority(int n)`: 可以让操作系统调用优先级便高, 但不能保证优先级高的线程一定会先执行
* `Thread.sleep()` 可以让当前线程暂停一段时间

## 线程的状态

* 线程的状态
  * New: 新创建的线程, 尚未执行
  * Runable: 运行中的线程, 正在执行`run()`方法的Java代码
  * Blocked: 运行中的线程, 因为某些操作被阻塞而挂起
  * Waiting: 运行中的线程, 因为某些操作再等待中
  * Timed Waiting: 运行中的线程, 因为执行`sleep()`方法正在计时等待
  * Terminated: 线程已终止, 因为`run()`方法执行完毕

* 线程再执行过程中, 可以在四种状态之间相互相互, 直到线程终止

* 线程终止的原因:
  * 线程正常终止: `run()`方法执行到`return`语句返回
  * 线程意外终止: `run()`方法因为未捕获异常导致线程终止
  * 对某个线程`Thread`实例调用`stop()`方法终止

* `t.join()`等待线程结束再继续执行

## 中断线程

* 中断线程就是其他线程给该线程发一个信号, 该线程收到信号后结束执行`run()`方法
* 在其他线程中对目标线程调用`interrupt()`方法
* 目标线程反复检测自身状态是否未`interrupted`状态, 如果是, 就立刻结束运行
* `interrupt()`仅仅是发出中断请求, 能不能立即中断, 要看具体代码
* 再具体代码中使用`isInterrupted`进行判断
* `t.join()`会让`main`线程进入等待状态
* 如果对`main`线程调用`interrupt()`, `join()`方法, 会立刻抛出`InterruptedException`
* 目标线程只要捕获到`join()`方法抛出的`InterruptedException`, 说明有其他线程对其调用了`interrupt`方法, 通常情况下线程应该立刻结束返回

```java
public class Main {
  public static void main(String[] args) throws InterruptedException {
    Thread t = new MyThread();
    t.start();
    Thread.sleep(100);
    t.interrupt(); // 中断t线程
    t.join(); // 等待t线程终止
    System.out.println("end");
  }
}

class MyThread extends Thread {
  public void run() {
    Thread hello = new HelloThread();
    hello.start(); // hello线程启动
    try {
      hello.join(); // 等待hello线程结束, 一旦t被终止, 就会停止等待, 立刻抛出异常
    } catch (InterruptedException e) {
      System.out.println("interrupted");
    }
    hello.interrupt(); // 中止hello线程, t线程结束前会对hello进行`interrupt`
  }
}

class HelloThread extends Thread {
  public void run() {
    int n = 0;
    while (!isInterrupted()) {
      n++;
      System.out.println(n + "hello");
      try {
        Thread.sleep(100);
      } catch (InterruptedException e) {
        break;
      }
    }
  }
}
```

* 另一个终止的方法: 设置标志位
* 通过`running`标志位停止线程运行

```java
public class Main {
  public static void main(String[] args) throws InterruptedException {
    HelloThread t = new HelloThread();
    t.start();
    Thread.sleep(1);
    t.running = false;
  }

}
class HelloThread extends Thread {
  public volatile boolean running = true;
  public void run() {
    int n = 0;
    while(running) {
      n++;
      System.out.println(n + "hello");
    }
    System.out.println("end!");
  }
}
```

* 存在与线程之间的变量用`volatile`修饰, 确保每个变量都能读到更新后的值

┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘

* 线程间变量关系
  * 在java虚拟机中变量的值保存再主内存中
  * 线程访问的时候先获取一个副本, 保存在自己的工作内存中
  * 如果线程改变了值, 虚拟机会在某个时刻把修改后的值写回到主内存中
  * *但是时间不确定*
* `volatile`关键字作用:
  * 每次访问变量时, 总是获取内存的最新值
  * 每次修改变量, 立刻回写到主内存
  * *解决了可见性的问题, 当一个线程修改了某个共享变量的值, 其他线程能够立刻看到修改后的值*

## 守护线程

* 守护线程是为其他线程服务的线程.
* 在JVM中, 所有非守护线程都执行完毕后, 无论有没有守护线程, 虚拟机都会自动退出.
* 再`start()`之前调用`setDaemon(true)`将线程变成守护线程
* *在守护线程不能持有任何需要关闭的资源.*
* 例如: 打开文件等, 因为虚拟机退出时, 守护线程没有任何机会来关闭文件, 这会导致数据丢失

## 线程同步

* *如果多个线程同时读写共享变量, 会出现数据不一致的问题*
* 对变量进行读取和写入时, 结果要正确, 必须保证是原子操作.
* 原子操作是指不能被中断的一个或一系列操作.
* 在多线程模型下, 要保证逻辑正确, 对共享变量进行读写时, 必须保证一组指令以原子方式执行.
* **即某一个线程执行时, 其他线程必须等待**

* 通过*加锁*和*解锁*的操作, 保证3条指令总是在一个线程执行期间, 不会有其他线程会进入此指令区间
* 加锁和解锁之间的代码块称之为临界区. 任何时候临界区最多只有一个线程能执行

* 保证一段代码的原子性, 就是通过加锁和解锁实现的.
* 使用关键字`synchronized`对一个对象进行加锁.

```java
      synchronized(Counter.lock) { // 获得锁
        ...
      } // 释放锁
```

* `synchronized`解决了多线程同步访问共享变量变量的正确性问题. 但是性能下降
* 如何使用:
  1. 找出修改共享变量的线程代码块
  2. 选择一个共享实例作为锁
  3. 使用`synchronized(lockObject){...}`
* 无论是否有异常, 都会在代码块结束的时候释放锁
* *获取到的是哪个锁非常重要*

### 不需要synchronized的操作

* 原子操作:
  * 基本类型(`long`和`double`除外)赋值
  * 引用类型赋值
* 单原子操作不需要同步
* *多行赋值语句, 就必须保证是同步操作*

* 巧妙转换, 就不需要同步操作了

```java
class Pair {
  int first;
  int last;
  public void set(int first, int last) {
    synchronized(this) {
      this.first = first;
      this.last = last;
    }
  }
}

class Pair2 {
  int[] pair;
  public void set(int first, int last) {
    int[] ps = new int[] {
        first,
        last
    }; //  这是`ps`方法内部定义的局部变量, 每个线程都会有各自的局部变量, 互补影响, 不需要同步
    this.pair = ps; // 这是一个原子操作
  }
}
```

## 同步方法

* *方法使用`synchronized(this)`进行锁定, 就会针对每次操作进行锁定*
* 如果一个类设计允许多线程正确访问, 这个类就是*线程安全的*
* 只有提供静态方法, 没有成员变量的类, 也是`线程安全的`
* 使用`synchronized`修饰方法, 表示整个方法使用`this`加锁, 就是同步方法
* 静态方法添加, 表示锁住该类的`class`实例

## 死锁

* JVM允许一个线程重复获取同一个锁
* 能被同一个线程反复获取的锁, 叫做可重入锁.
* 获取锁的是, 需要记录第几次获取, 每获取一次锁, 记录+1, 退出一次, 记录-1, 一直到0.

### 死锁介绍

* 一个线程获取一个锁以后, 再获取另一个锁.
* 两个线程各自持有不同的锁, 然后试图尝试获取对方手里的锁, 造成爽发无限等待下去, 这就是死锁.
* 死锁发生活, 没有任何机制能解除死锁, 只能强制结束JVM进程
* 避免死锁方法: *线程获取锁的顺序保持一致*

## 使用wait和notify

* `synchronized`解决了多线程竞争的问题, 但没有解决多线程协助的问题
* 多线程协调运行原则:
  * 当条件不满足时, 线程进入等到状态;
  * 当条件满足时, 线程被唤醒, 继续执行任务;
* `notifyAll()`更安全, 一次性唤醒全部线程.

```java
public class Main {
  public static void main(String[] args) throws InterruptedException {
    TaskQueue q = new TaskQueue();
    ArrayList<Thread> ts = new ArrayList<Thread> ();
    for (int i = 0; i < 5; i++) { // 模拟不同的线程抢着获取任务
      Thread t = new Thread() {
        public void run() {
          while (true) { // 任务不断循环, 因为每次都是唤醒所有, 所有用`while`, 重新上锁并等待
            try {
              String s = q.getTask();
              System.out.println("execute task: " + this.getName() + " " + s);
            } catch (InterruptedException e) {
              return;
            }
          }
        }
      };
      t.start();
      ts.add(t);
    }

    Thread add = new Thread() {
      public void run() {
        for (int i=0; i<10;i++) { // 放了十个task
          // 放入task
          String s = "t-" + Math.random();
          System.out.println("add task: " + s);
          q.addTask(s);
          try {Thread.sleep(100);}  catch (InterruptedException e) {}
        }
      }
    };
    add.start();
    add.join();
    Thread.sleep(100);
    for(Thread tItem : ts) {
      tItem.interrupt();
    }
  }
}

class TaskQueue {
  Queue<String> queue = new LinkedList<>();
  public synchronized void addTask(String s) {
    this.queue.add(s);
    this.notifyAll(); // 唤醒this锁等待的所有线程
  }
  public synchronized String getTask() throws InterruptedException {
    while (queue.isEmpty()) { // 先判断队列是否为空, 为空等待循环, 不为空的时候, 取第一个元素
      // 释放this锁
      this.wait(); // wait方法不会返回, 需要等待从其他线程唤醒, 才会继续执行
      // 重新获取this锁
    }
    return queue.remove();
  }
}
```

## 使用ReentrantLock

* `synchronized`关键字用于加锁
  * 锁很重,性能不好
  * 获取时必须一直等待, 没有额外的尝试机制
* `ReentrantLock`是Java代码实现的锁, 必须先获取锁, 然后再`finally`中释放
* `ReentrantLock`是可重入锁, 一个线程可以多次获取同一个锁
* 可以尝试获取锁.

```java
    if (lock.tryLock(1, TimeUnit.SECONDS)) { // 尝试获取锁, 最多等待1s, 如果1s后未获取, `tryLock`返回`false`
      try {
        // ...
      } finally {
        lock.unlock();
      }
    }
```

## 使用Condition

* `Condition`对象实现`wait`和`notify`的功能.

```java
class TaskQueue {
  private final Lock lock = new ReentrantLock();
  private final Condition condition = lock.newCondition();
  private Queue<String> queue = new LinkedList<>();
  public void addTask(String s) {
    lock.lock(); // 获取锁
    try {
      queue.add(s);
      condition.signalAll(); // 唤醒正在等等的所有线程
    } finally {
      lock.unlock(); // 结束了就释放锁
    }
  }
  public String getTask() throws InterruptedException {
    lock.lock(); // 获取锁
    try {
      while(queue.isEmpty()) { // 判断队列是否为空
        condition.await(); // 队列为空, 释放锁, 进入等待
      }
      return queue.remove();
    } finally {
      lock.unlock();
    }
  }
}
```

* 与`synchronized`锁对象行为基本保持一致
  * `await()`会释放当前锁, 进入等待状态
  * `signal()`会唤醒某个线程的等待
  * `signalAll()`会唤醒所有等待的锁
  * 线程从`await()`返回后需要重新获得锁.
* 可以指定等待唤醒时间

```java
    if (condition.await(1, TimeUnit.SECONDS)) {
      // 被其他线程唤醒
    } else {
      // 指定时间内没有被其他线程唤醒
    }
```
